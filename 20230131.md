#C++ 语法学习
《C++程序设计》谭浩强
基于对象的程序设计

## 类和对象的特性
### 面向对象
- 以类对象为基本构成单位的程序称为基于对象的程序
- 面向对象程序设计的四个特点：抽象、封装、继承和多态
- 对象（Object）由属性（attribute）和行为/方法（behavior/method）构成
- 封装（encapsulation）：使对象间相互独立，使对象的部分对外隐蔽，隐蔽的同时留下接口便于与外界联系
- 抽象（abstraction）：表示同类事物的本质，类是对象的抽象，对象是类的特例
- 继承与重用
- 多态（polymorphism）：由继承而产生的不同派生类，其对象对同一消息会做出不同的响应
- 面向过程：程序 = 算法 + 数据结构
- 面向对象：对象 = 算法 + 数据结构
- 面向对象：程序 = （对象 + 对象 + ……）+ 消息
### 类的声明和对象的定义
- 类的声明:
        
        class Date{
            int year;
            int month;
            int day;
            void display(){
                cout << year << " " << month << "-" << day <<endl;
            }
        };
- 成员访问限定符：private  public  protected
- 不写默认 private
- private 私有成员只能被本类中的成员函数引用
- public 公有成员可以被类的作用域内的其他函数引用
- protected 受保护成员不能被类外访问，但可以被派生类的成员访问
- 书写习惯：先写 private 后写 public
### 类的成员函数
- 可以在类体中只对成员函数进行声明，而在类外进行函数定义
        
        class Date{
        public:
            void display();
        }
        void Date::display(){
           cout << year << " " << month << "-" << day <<endl; 
        }
- "::"是作用域限定符
- 内置成员函数：类的方法也可以指定为内置函数 inline
- 每个对象所占用的存储空间只是该对象的数据成员所占用的存储空间，而不包括函数代码所占用的存储空间
### 对象成员的引用
- 通过对象名和成员运算符访问对象中的成员
- 通过指向对象的指针访问对象中的成员
- 通过对象的引用访问对象中的成员
### 类的封装性和信息隐蔽
- 在面向对象的程序设计中，一般把所有的数据（属性）都指定为 private，把需要外界调用的成员函数（方法）指定为 public，时属性与外界隔离，只能通过方法进行交流
- 公用成员函数是用户使用类的公用接口或类的对外接口
- 接口与实现的分离
- 类的公用接口和私有实现的分离形成了信息隐蔽
- 类声明和成员函数定义的分离：类声明和函数定义往往在两个文件中

## 怎样使用类和对象
### 构造函数
- 参数初始化表：
    
        Date::Date(int a,int b,int c):year(a),month(b),day(c){}
- 构造函数的重载
- 构造函数的默认参数
### 析构函数
- 析构函数的作用不是删除对象而是在撤销对象占用内存之前完成一些清理工作
- 析构函数没有函数类型，没有函数参数也不能被重载
- 先构造的后析构，后构造的先析构（先进后出）
### 对象数组
- 由类对象组成的数组
### 对象指针
- 对象空间的起始地址就是对象的指针
- 指向对象数据成员的指针和指向类成员函数的指针
    
        Date date(2023,2,1);
        int * p;
        p = &date.day;  //指向对象属性的指针
        void (Date::*p)();
        p = &Date::display(); //指向类方法的指针
- this 指针指向调用成员函数所在对象的起始地址，即
    
        void Date::display(){
           cout << year << " " << month << "-" << day <<endl; 
        }
        //相当于
        void Date::display(){
           cout << this->year << " " << this->month << "-" << this->day <<endl; 
        }
        
### 共用数据的保护
- 常对象 const Date date(2023,2,1) //常对象必须要有初值且数据成员不能被修改
- 常对象只能调用其类的常成员函数，不能调用普通成员函数
- 常对象的常成员函数可以访问常对象的数据，但是不能对其进行修改
- 常对象的可变数据成员 mutable
- mutable 声明的数据成员可以用常成员函数修改它的值
- 常数据成员（常属性），使用 const 声明，初始化后不能改变，只能使用参数初始化表对其进行初始化
- 常成员函数（常方法），使用 const 声明，常方法只能引用该对象的属性而不能修改属性的值
- 指向对象的常指针，指针变量的指向不变
- 指向常对象的指针变量，可以指向非常对象，此时通过指针访问对象的值但不能修改对象的值（常对象指针指向非常对象时，非常对象具有常对象的特征）
    
        class Date{
        public:
            const int hour;         //常属性
            Date(int a):hour(a){};  //常属性的初始化
            void printDate()const;  //常方法
        }
        const Date date(12);   //常对象
        Date const date2(13); //常对象，等价于上式
        Date date3(14);      //普通对象
        Date * const p;     //声明常指针
        p = &date3;        //指向经过初始化的对象的常指针
        const Date * p2;
        p2 = &date3;      //指向非常对象的常对象指针，此时通过p2不能修改对象的值
        p2->hour = 11;            //非法，不能修改
        cout << p2->hour <<endl; //合法，能够读取

- 当希望在调用函数时对象的值不被修改，就应当把形参定义为指向常对象的指针变量，同时用（常或非常）对象的地址作实参
- 对象的常引用：如果不希望函数修改实参对象的值，可以把形参声明为对象的常引用
    
        void func(const Date &date);
        
### 对象的动态建立与释放
- 使用指针变量存储动态对象
    
        Date * p;
        p = new Date(12);
        cout << p->hour <<endl;
        cout << (*P).hour <<endl;
        delete p;  //在调用delete 删除对象前会自动调用析构函数
        

### 对象的赋值和复制
- 对象赋值：本质上是对象成员的复制（不能包含动态分配的数据）
    
        Date date1,date2;
        date1 = date2;
- 对象复制：通过复制构造函数（不能包含动态分配的数据）
    
        Date date1;
        Date date2(date1);
        Date date3 = date1;
### 静态成员
- 静态数据成员（属性）：被所有对象共享
- 静态属性只能在类体外初始化
    
        class Date{
        public:
            static int year;
        }
        int Date::year = 2022;     //类体外初始化
        int main(){
            Date date1,date2;
            cout << date1.year <<endl;  //output:2022
            date1.year = 2023;
            cout << date2.year <<endll   //output:2023 数据共享
        }
- 静态成员函数：是类的一部分而不是对象的一部分
- 静态成员函数没有this指针，不属于任何对象，无法对非静态对象进行访问
### 友元
- 友元函数：可以访问类中私有属性的类外函数
    
        class Date{
        public:
            friend void display(Date &);  //声明display为Date的友元函数
        private:
            int hour;
        }
        void display(Date &date){
            cout << date.hour << endl;
        }

- 友元函数可以是另一类中的成员函数
- 友元类：类中的所有成员函数都是另一个类的友元函数
    
        class A{
        public:
            friend B;
        }
        class B{
            
        }
### 类模板

## 运算符重载
### 什么是运算符重载
- 重载（overloading）
### 运算符重载的方法
- 运算符重载的实质是函数的重载
- 函数类型 operator 运算符名称（形参表）{对运算符的重载处理}
    
        int operator + (int a,int b){
            return (a+b);
        }
        
### 重载运算符的规则
- C++ 不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载；
- C++ 允许重载的运算符有：双目运算符（+，-，/），关系运算符（==，<,>），逻辑运算符，赋值运算符，位运算符，空间申请与释放（new ，delete，new[]），其他运算符（->，[]，()）
- C++ 不允许重载的运算符有 5 个 ：
1. 成员访问运算符    .
1. 成员指针访问运算符   *
1. 域运算符             ::
1. 长度运算符        sizeof
1. 条件运算符       ?:
- 重载不能改变运算符运算对象的个数
- 重载不能改变运算符的优先级别
- 重载不能改变运算符的结合性
- 重载运算符的函数不能有默认的参数
- 重载运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象（或类对象的引用）
- 用于类对象的运算符一般必须重载，除了"="和"&"
- 从理论上说，可以将一个运算符重载为执行任意的操作
### 运算符重载函数作为类成员函数和友元函数
### 重载双目运算符
### 重载单目运算符
### 重载流插入运算符<<和流提取运算符>>
### 不同类型数据间的转换

## 继承与派生
### 继承 inheritance
- 继承 ：一个新类从已有的父类那里获得父类的特性
- 派生 ：从已有的父类产生一个新的子类
- 单继承：一个派生类只从一个基类派生
- 多重继承：一个派生类有两个或多个基类
- 派生类的基类的具体化，而基类则是派生类的抽象
### 派生类的声明方式
- 示例：
    
        class Student : public People {}
- People 是基类，Student 是派生类
- public 声明为 公用继承 方式
- 继承方式包括：public ,private, protected
### 派生类的构成
- 派生类的组成：
- 1）从基类接收成员；
- - 接收基类除构造函数和析构函数之外所有的成员，C++目前无法解决基类的成员冗余问题；
- 2）调整从基类接收的成员；
- - 接收基类的成员是难以选择的，但可以进行调整：修改成员访问属性（通过继承方式），覆盖继承的属性和方法，重写继承的方法
- 3）在声明派生类时增加的成员；
### 派生类成员的访问属性
- 公用继承 public
基类中 private 对于派生类不可访问
基类中 protected 对于派生类来说还是 protected
基类中 public 对于派生类来说还是 public

- 私有继承 private
基类中 private 对于派生类不可访问
基类中 protected 对于派生类来说是 private
基类中 public       对于派生类来说是 private

- 保护继承 protected
基类中 private 对于派生类不可访问
基类中 protected 对于派生类来说是 protected
基类中 public       对于派生类来说是 protected

- 多级派生时的访问属性

### 派生类的构造函数和析构函数
### 多重继承

    class D:public A,private B,protected C{ }
    
- 虚基类
### 基类与派生类的转换
- 赋值兼容
### 继承与组合
- 组合 composition
在一个类中以另一个类的对象作为数据成员
- 继承是纵向的，组合是横向的

## 多态性与虚函数
### 多态 polymorphism
- 向不同的对象发送同一消息，不同的对象在接收时会产生不同的行为
- 静态多态：通过函数重载（和运算符重载）实现
要求在程序编译时就知道调用函数的全部信息，又称编译时的多态性
- 动态多态：通过虚函数实现
编译时不确定调用哪个函数，运行过程中动态确定操作所针对的对象，又称运行时的多态性
### 虚函数
### 纯虚函数与抽象类

## 输入输出流
### C++的输入输出
- 相比于C的printf和scanf，C++的I/O操作是 类型安全 和 可扩展性的
- C语言采用函数进行输入输出，C++采用类对象来实现输入输出
- C++ 的流库
### 标准输出流
- cout
- cerr  标准错误流-不经过缓冲区直接向显示器上输出有关信息
- clog 标准错误流-错误信息存放缓冲区，缓冲区满或endl时向显示器输出
### 标准输入流
- cin
### 对数据文件的操作与文件流
### 字符串流

## C++工具
### 异常处理
### 命名空间











